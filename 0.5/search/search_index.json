{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dbt_meshify","text":"<p><code>dbt-meshify</code> is a CLI tool that automates the creation of model governance and cross-project lineage features introduced in dbt-core v1.5 and v1.6. This package will leverage your dbt project metadata to create and/or edit the files in your project to properly configure the models in your project with these features.</p> <p>These features include:</p> <ol> <li>Groups - group your models into logical sets.</li> <li>Contracts - add model contracts to your models to ensure consistent data shape.</li> <li>Access - control the <code>access</code> level of models within groups</li> <li>Versions - create and increment versions of particular models.</li> <li>Project dependencies - split a monolithic dbt project into component projects, or connect multiple pre-existing dbt projects using cross-project <code>ref</code>.</li> </ol> <p>This package leverages the dbt-core Python API to allow users to use standard dbt selection syntax for each of the commands in this package (unless otherwise noted). See details on each of the specific commands available on the commands page.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>This package helps automate the code development required for adding the model governance and cross-project lineage features mentioned above.</p> <p>The first question to ask yourself is \"which of these features do I want to add to my project\"? Do you want to add contracts, create a new group, split your monolithic dbt project in two? Your answer to this question will establish which <code>dbt-meshify</code> command is right for you!</p> <p>This package consists of component and global commands - so you can decide how to best break apart your work.</p> <p>The component commands allow you to do a single step at a time and begin with <code>dbt-meshify operation</code>. For example, if you wanted to add a new version to a model, you would run something like <code>dbt-meshify operation add-version --select fct_orders</code>. This command would:</p> <ol> <li>add version configuration values to <code>fct_orders</code></li> </ol> <p>and that's it!</p> <p>The global commands combine multiple component commands to complete a larger set of work and begin with <code>dbt-meshify</code>. For example, if you wanted to define a group for a subset of your models, you would run something like <code>dbt-meshify group finance --owner-name \"Monopoly Man\" --select +tag:finance</code>. This command would:</p> <ol> <li>define a new group named \"finance\" in your dbt project, setting the owner name to \"Monopoly Man\"</li> <li>add all models tagged with \"finance\" to that new group</li> <li>set <code>access</code> to protected for all \"leaf\" models (models with no downstream dependencies) and models with cross-group dependencies</li> <li>add contracts to all protected nodes</li> </ol> <p>all at once!</p> <p>The next question to ask yourself is \"which of my models do I want to add these features to?\". This informs the selection syntax you provide to the <code>dbt-meshify</code> command of choice. <code>dbt-meshify</code> uses the same selection syntax as <code>dbt</code>, so you can use the <code>--select</code>, <code>--exclude</code> and <code>--selector</code> flags to select resources based on model names, tags, and so on!</p> <p>Once you've decided:</p> <ol> <li>which feature(s) you want to add to your dbt project</li> <li>which subset of models you want to add those feature(s) to</li> </ol> <p>you're ready to use <code>dbt-meshify</code>!</p> <p>For further information, check out the available commands or read through some examples.</p>"},{"location":"#what-dbt-meshify-does-not-handle","title":"What dbt-meshify does not handle","text":"<p>There are a handful of known edge cases that this package does not automatically handle. In these cases, we recommend doing a manual check to make sure you've handled these appropriately:</p> edge case manual check <code>dbt-meshify split</code> copies over the entire contents of the <code>packages.yml</code> file from the original project to the new subproject remove unnecessary packages from each project <code>dbt-meshify split</code> makes a copy of all necessary macros from the original project to the new subproject consider creating a private \"macros only\" project to install as a package into all of your other projects, instead of maintaining duplicate copies of shared macros"},{"location":"commands/","title":"dbt-meshify Commands","text":""},{"location":"commands/#dbt-meshify","title":"dbt-meshify","text":"<p>Usage:</p> <pre><code>dbt-meshify [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --dry-run\n  --debug\n  --version  Show version information and exit\n  --help     Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>connect: </li> <li>group: </li> <li>operation: </li> <li>split: </li> <li>version: </li> </ul>"},{"location":"commands/#dbt-meshify-connect","title":"dbt-meshify connect","text":"<p>Connects multiple dbt projects together by adding all necessary dbt Mesh constructs</p> <p>Usage:</p> <pre><code>dbt-meshify connect [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --project-paths TUPLE         The paths to the set of dbt projects to\n                                connect. Must supply 2+ paths.\n  --projects-dir PATH           The path to a directory containing multiple\n                                dbt projects. Directory must contain 2+\n                                projects.\n  -e, --exclude-projects TUPLE  The set of dbt projects to exclude from the\n                                operation when using the --projects-dir\n                                option.\n  -r, --read-catalog            Skips the dbt docs generate step and reads the\n                                local catalog.json file.\n  --help                        Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-group","title":"dbt-meshify group","text":"<p>Creates a new dbt group based on the selection syntax Detects the edges of the group, makes their access protected, and adds contracts to them</p> <p>Usage:</p> <pre><code>dbt-meshify group [OPTIONS] NAME\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE      The dbt selection syntax specifying the resources\n                           to exclude in the operation\n  --group-yml-path PATH    An optional path to store the new group YAML\n                           definition.\n  --owner-email TEXT       The group Owner's email address.\n  --owner-name TEXT        The group Owner's name.\n  --owner-properties TEXT  Additional properties to assign to a group Owner.\n  --project-path PATH      The path to the dbt project to operate on. Defaults\n                           to the current directory.\n  -r, --read-catalog       Skips the dbt docs generate step and reads the\n                           local catalog.json file.\n  -s, --select TUPLE       The dbt selection syntax specifying the resources\n                           to include in the operation\n  --selector TUPLE         The name(s) of the YML selector specifying the\n                           resources to include in the operation\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-operation","title":"dbt-meshify operation","text":"<p>Set of subcommands for performing mesh operations on dbt projects</p> <p>Usage:</p> <pre><code>dbt-meshify operation [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>add-contract: </li> <li>add-version: </li> <li>bump-version: </li> <li>create-group: </li> </ul>"},{"location":"commands/#dbt-meshify-operation-add-contract","title":"dbt-meshify operation add-contract","text":"<p>Adds a contract to all selected models.</p> <p>Usage:</p> <pre><code>dbt-meshify operation add-contract [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE  The dbt selection syntax specifying the resources to\n                       exclude in the operation\n  --project-path PATH  The path to the dbt project to operate on. Defaults to\n                       the current directory.\n  -r, --read-catalog   Skips the dbt docs generate step and reads the local\n                       catalog.json file.\n  -s, --select TUPLE   The dbt selection syntax specifying the resources to\n                       include in the operation\n  --selector TUPLE     The name(s) of the YML selector specifying the\n                       resources to include in the operation\n  --help               Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-operation-add-version","title":"dbt-meshify operation add-version","text":"<p>Adds model version boilerplate for all selected models.</p> <p>Usage:</p> <pre><code>dbt-meshify operation add-version [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE  The dbt selection syntax specifying the resources to\n                       exclude in the operation\n  --project-path PATH  The path to the dbt project to operate on. Defaults to\n                       the current directory.\n  -r, --read-catalog   Skips the dbt docs generate step and reads the local\n                       catalog.json file.\n  -s, --select TUPLE   The dbt selection syntax specifying the resources to\n                       include in the operation\n  --selector TUPLE     The name(s) of the YML selector specifying the\n                       resources to include in the operation\n  --defined-in TEXT\n  --help               Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-operation-bump-version","title":"dbt-meshify operation bump-version","text":"<p>Create new model versions for all selected models.</p> <p>Usage:</p> <pre><code>dbt-meshify operation bump-version [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE  The dbt selection syntax specifying the resources to\n                       exclude in the operation\n  --project-path PATH  The path to the dbt project to operate on. Defaults to\n                       the current directory.\n  -r, --read-catalog   Skips the dbt docs generate step and reads the local\n                       catalog.json file.\n  -s, --select TUPLE   The dbt selection syntax specifying the resources to\n                       include in the operation\n  --selector TUPLE     The name(s) of the YML selector specifying the\n                       resources to include in the operation\n  -l, --latest         Makes the newest version the latest version when\n                       incrementing model versions\n  --defined-in TEXT\n  --help               Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-operation-create-group","title":"dbt-meshify operation create-group","text":"<p>Create a group and add selected resources to the group.</p> <p>Usage:</p> <pre><code>dbt-meshify operation create-group [OPTIONS] NAME\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE      The dbt selection syntax specifying the resources\n                           to exclude in the operation\n  --group-yml-path PATH    An optional path to store the new group YAML\n                           definition.\n  --owner-email TEXT       The group Owner's email address.\n  --owner-name TEXT        The group Owner's name.\n  --owner-properties TEXT  Additional properties to assign to a group Owner.\n  --project-path PATH      The path to the dbt project to operate on. Defaults\n                           to the current directory.\n  -r, --read-catalog       Skips the dbt docs generate step and reads the\n                           local catalog.json file.\n  -s, --select TUPLE       The dbt selection syntax specifying the resources\n                           to include in the operation\n  --selector TUPLE         The name(s) of the YML selector specifying the\n                           resources to include in the operation\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-split","title":"dbt-meshify split","text":"<p>Splits out a new subproject from a dbt project by adding all necessary dbt Mesh constructs to the resources based on the selected resources.</p> <p>Usage:</p> <pre><code>dbt-meshify split [OPTIONS] PROJECT_NAME\n</code></pre> <p>Options:</p> <pre><code>  --create-path PATH   The path to create the new dbt project. Defaults to the\n                       name argument supplied.\n  -e, --exclude TUPLE  The dbt selection syntax specifying the resources to\n                       exclude in the operation\n  --project-path PATH  The path to the dbt project to operate on. Defaults to\n                       the current directory.\n  -r, --read-catalog   Skips the dbt docs generate step and reads the local\n                       catalog.json file.\n  -s, --select TUPLE   The dbt selection syntax specifying the resources to\n                       include in the operation\n  --selector TUPLE     The name(s) of the YML selector specifying the\n                       resources to include in the operation\n  --help               Show this message and exit.\n</code></pre>"},{"location":"commands/#dbt-meshify-version","title":"dbt-meshify version","text":"<p>Increment the models to the next version, and create in the initial version if it has not yet been defined.</p> <p>Usage:</p> <pre><code>dbt-meshify version [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -e, --exclude TUPLE  The dbt selection syntax specifying the resources to\n                       exclude in the operation\n  --project-path PATH  The path to the dbt project to operate on. Defaults to\n                       the current directory.\n  -r, --read-catalog   Skips the dbt docs generate step and reads the local\n                       catalog.json file.\n  -s, --select TUPLE   The dbt selection syntax specifying the resources to\n                       include in the operation\n  --selector TUPLE     The name(s) of the YML selector specifying the\n                       resources to include in the operation\n  -l, --latest         Makes the newest version the latest version when\n                       incrementing model versions\n  --defined-in TEXT\n  --help               Show this message and exit.\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>For consistency and clarity of the following examples, we're going to use a simplified dbt project. In practice, the model governance and cross-project lineage features describe are most beneficial for large dbt projects that are struggling to scale.</p> <p>We will give a basic example for each command, but to see the full list of additional flags you can add to a given command, check out the commands page.</p> <p>Note</p> <p>One helpful flag that you can add to all of the commands is <code>--read-catalog</code>, which will skip the <code>dbt docs generate</code> step and instead read the local <code>catalog.json</code> file - this will speed up the time it takes to run the <code>dbt-meshify</code> commands but relies on your local <code>catalog.json</code> file being up-to-date. Alternatively, you can configure this via the <code>DBT_MESHIFY_READ_CATALOG</code> environment variable.</p> <p>Let's imagine a dbt project with the following models: </p> <p>You can checkout the source code for this example here.</p>"},{"location":"examples/#component-commands","title":"Component commands","text":""},{"location":"examples/#create-a-new-group","title":"Create a new group","text":"<p>Let's say you want to create a new group for your sales analytics models. </p> <p>You can run the following command:</p> <pre><code>dbt-meshify operation create-group sales_analytics --owner-name Ralphie --select +int_sales__unioned +int_returns__unioned transactions\n</code></pre> <p>This will create a new group named \"sales_analytics\" with the owner \"Ralphie\" and add all selected models to that group with the appropriate <code>access</code> configuration:</p> <ul> <li> <p>create a new group definition in a <code>_groups.yml</code> file:   </p> </li> <li> <p>add all selected models to that group with the appropriate <code>access</code> config</p> </li> <li>all models that are only referenced by other models in their same group will have <code>access: private</code> </li> <li>all other models (those that are referenced by models outside their group or are \"leaf\" models) will have <code>access: protected</code> </li> </ul>"},{"location":"examples/#addincrement-model-versions","title":"Add/increment model versions","text":"<p>Let's say you want to add a new version to the customers model, which is currently un-versioned. Versions can provide a smoother upgrade pathway when introducing breaking changes to models that have downstream dependencies.</p> <p></p> <p>You can run the following command:</p> <pre><code>dbt-meshify version --select customers\n</code></pre> <p>This will add a version to the <code>customers</code> model for your current version, and will add a new version for breaking change you wish to implement:</p> <ul> <li>the <code>customers.sql</code> file will be renamed to <code>customers_v1.sql</code></li> <li>a new <code>customers_v2.sql</code> file will be created based on <code>customers_v1.sql</code></li> <li>the necessary version configurations will be created (or added to a pre-existing <code>yml</code> file)   </li> </ul>"},{"location":"examples/#add-contracts","title":"Add contract(s)","text":"<p>Let's say you want to add a new contract to the <code>stores</code> model, which is currently un-contracted. </p> <p>You can run the following command:</p> <pre><code>dbt-meshify operation add-contract --select stores\n</code></pre> <p>This will add an enforced contract to the <code>stores</code> model:</p> <ul> <li>add a <code>contract</code> config and set <code>enforced: true</code> </li> <li>add every column's <code>name</code> and <code>data_type</code> if not already defined   </li> </ul>"},{"location":"examples/#global-commands","title":"Global commands","text":""},{"location":"examples/#group-together-a-subset-of-models","title":"Group together a subset of models","text":"<p>Let's say you want to group together your sales analytics models - create a new group and add contracts to appropriate models simultaneously. </p> <p>You can run the following command:</p> <pre><code>dbt-meshify group sales_analytics --owner-name Ralphie --select +int_sales__unioned +int_returns__unioned transactions\n</code></pre> <p>This will create a new group named \"sales_analytics\" with the owner \"Ralphie\", add all selected models to that group with the appropriate <code>access</code> configuration, _and add contracts to the models at the boundary between this group and the rest of the project__:</p> <ul> <li>create a new group definition in a <code>_groups.yml</code> file   </li> <li>add all selected models to that group with the appropriate <code>access</code> config</li> <li>all models that are only referenced by other models in their same group will have <code>access: private</code> </li> <li>all other models (those that are referenced by models outside their group or are \"leaf\" models) will have <code>access: protected</code> </li> <li>for all <code>protected</code> models:</li> <li>add a <code>contract</code> config and set <code>enforced: true</code> </li> <li>add every column's <code>name</code> and <code>data_type</code> if not already defined     </li> </ul>"},{"location":"examples/#split-out-a-new-subproject","title":"Split out a new subproject","text":"<p>Let's say you want to split our your sales analytics models into a new subproject. </p> <p>You can run the following command:</p> <pre><code>dbt-meshify split sales_analytics --select +int_sales__unioned +int_returns__unioned transactions\n</code></pre> <p>This will create a new subproject that contains the selected sales analytics models, configure the \"edge\" models to be <code>public</code> and contracted, and replace all dependencies in the downstream project on the upstreams's models with cross-project <code>ref</code>s:</p> <ul> <li> <p>create a new subproject that contains the selected sales analytics models   </p> </li> <li> <p>add a <code>dependencies.yml</code> to the downstream project (in our case, our new subproject is downstream of the original project because the <code>transactions</code> model depends on some of the models that remain in the original project - <code>stores</code> and <code>customers</code>)   </p> </li> <li>add <code>access: public</code> to all \"leaf\" models (models with no downstream dependencies) and models in the upstream project that are referenced by models in the downstream project   </li> <li>for all <code>public</code> models:</li> <li>add a <code>contract</code> config and set <code>enforced: true</code> </li> <li>add every column's <code>name</code> and <code>data_type</code> if not already defined     </li> <li>replace any dependencies in the downstream project on the upstream's models with a cross-project <code>ref</code> </li> </ul> <p>By default, the new subproject will be created in the current directory; however, you can use the <code>--create-path</code> flag to create it in any directory you like.</p>"},{"location":"examples/#connect-multiple-dbt-projects","title":"Connect multiple dbt projects","text":"<p>Let's look at a slightly modified version of the example we've been working with. Instead of a single dbt project, let's imagine you're starting with two separate dbt projects connected via the \"source hack\":</p> <ul> <li>project A contains the following models   </li> <li>project B contains the following models   </li> </ul> <p>We call this type of multi-project configuration the \"source hack\" because there are models generated by project A (<code>stores</code> and <code>customers</code>) that are defined as sources in project B.</p> <p>Let's say we want to connect these two projects using model governance best practices and cross project <code>ref</code>s.</p> <p>You can run the following command:</p> <pre><code>dbt-meshify connect --project-paths path/to/project_a path/to/project_b\n</code></pre> <p>This will make the upstream project a dependency for the downstream project, configure the \"edge\" models to be <code>public</code> and contracted, and replace all dependencies in the downstream project on the upstreams's models with cross-project <code>ref</code>s:</p> <ul> <li>add a <code>dependencies.yml</code> to the downstream project (in our case, project B is downstream of project A because the <code>transactions</code> model depends on some of the models that are generated by project A - <code>stores</code> and <code>customers</code>)   </li> <li>add <code>access: public</code> to all models in the upstream project that are referenced by models in the downstream project   </li> <li>for all <code>public</code> models:</li> <li>add a <code>contract</code> config and set <code>enforced: true</code> </li> <li>add every column's <code>name</code> and <code>data_type</code> if not already defined     </li> <li>replace any dependencies in the downstream project on the upstream's models with a cross-project <code>ref</code> </li> <li>remove unnecessary sources   </li> </ul>"}]}